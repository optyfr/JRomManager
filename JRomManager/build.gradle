plugins {
	id 'java' 
	id "org.sonarqube"
//	id 'eclipse' apply false
	id "de.undercouch.download" version "5.1.0"
	id "nebula.ospackage" version "9.1.1"
	id "de.inetsoftware.setupbuilder" version "7.2.13"
	id "org.javamodularity.moduleplugin" version "1.8.11"
	id "io.freefair.lombok" version "6.4.3"
    id 'org.openjfx.javafxplugin' version '0.0.13'
	id "org.beryx.jlink" version "2.25.0"
	id 'jacoco'
}

sonarqube {
	properties {
		property "sonar.projectBaseDir", ".."
		property "sonar.sourceEncoding", "utf-8"
		property "sonar.log.level", "INFO"
		property "sonar.verbose", "true"
		property "sonar.exclusions", "**/compressors/zipfs/*.java"
		property "sonar.scm.provider", "github"
		property "sonar.coverage.exclusions", "**/src-jfx/**/*"
		property "sonar.coverage.jacoco.xmlReportPaths", "${rootDir}/JRomManager/build/reports/jacoco/codeCoverageReport/codeCoverageReport.xml"
	}
}

tasks.register("codeCoverageReport", JacocoReport) {
    // If a subproject applies the 'jacoco' plugin, add the result it to the report
    subprojects { subproject ->
        subproject.plugins.withType(JacocoPlugin).configureEach {
            subproject.tasks.matching({ t -> t.extensions.findByType(JacocoTaskExtension) }).configureEach { testTask ->
                sourceSets subproject.sourceSets.main
                executionData(testTask)
            }
/*
            // To automatically run `test` every time `./gradlew codeCoverageReport` is called,
            // you may want to set up a task dependency between them as shown below.
            // Note that this requires the `test` tasks to be resolved eagerly (see `forEach`) which
            // may have a negative effect on the configuration time of your build.
            subproject.tasks.matching({ t -> t.extensions.findByType(JacocoTaskExtension) }).forEach {
                rootProject.tasks.codeCoverageReport.dependsOn(it)
            }*/
        }
    }

    // enable the different report types (html, xml, csv)
    reports {
        // xml is usually used to integrate code coverage with
        // other tools like SonarQube, Coveralls or Codecov
        xml.enabled true

        // HTML reports can be used to see code coverage
        // without any external tools
        html.enabled true
    }
}

codeCoverageReport.dependsOn {
    subprojects*.test
}


apply plugin: 'java'
sourceCompatibility = 17
targetCompatibility = 17
apply plugin: 'eclipse'
eclipse {
	classpath {
		downloadJavadoc = true
		downloadSources = true
	}
}


lombok {
	version = '1.18.20'
	config['lombok.extern.findbugs.addSuppressFBWarnings'] = 'false'
}

ext.props = new Properties()
file("dist/ver.properties").withInputStream { props.load(it) }

version = props.getProperty("Specification-Version")+'.'+props.getProperty("Implementation-Version")

repositories {
	mavenCentral()
	maven { url "https://jitpack.io" }
}

configurations.all {
	resolutionStrategy.cacheChangingModulesFor 0, 'seconds'
}

boolean isConGradle(entry) {
	entry.kind == 'con' && entry.path == 'org.eclipse.buildship.core.gradleclasspathcontainer'
}



task WebClientJar(type: Jar, dependsOn: [':WebClient:build']) {
	archiveBaseName = 'jrm-webui'
	from (new File(project(':WebClient').buildDir,"/gwt/out")) {
		into('webclient')
	}
	from (new File(project(':WebClient').projectDir,"/war/index.html")) {
		into('webclient')
	}
	from ('certs') {
		into('certs')
	}
}

import org.gradle.api.tasks.testing.logging.TestExceptionFormat
import org.gradle.api.tasks.testing.logging.TestLogEvent

subprojects {
	apply plugin: 'java'
	sourceCompatibility = 17
	targetCompatibility = 17
//	apply plugin: 'org.javamodularity.moduleplugin'
//	apply plugin: 'eclipse'

	version = props.getProperty("Specification-Version")+'.'+props.getProperty("Implementation-Version")
	repositories {
		mavenCentral()
		maven { url "https://jitpack.io" }
	}
	ext.moduleName = 'minimal.json'

	compileJava {
		inputs.property('moduleName', moduleName)
		doFirst {
			options.compilerArgs = [
				'--module-path', classpath.asPath,
			]
			classpath = files()
		}
	}

	test {
		useJUnitPlatform {
			includeEngines 'junit-jupiter'
		}
		jacocoTestReport {
			reports {
				xml.enabled true
			}
		}
		finalizedBy jacocoTestReport
	}
	
	sonarqube {
		properties {
			property "sonar.projectBaseDir", ".."
			property "sonar.sourceEncoding", "utf-8"
			property "sonar.log.level", "INFO"
			property "sonar.verbose", "true"
			property "sonar.exclusions", "**/compressors/zipfs/*.java"
			property "sonar.scm.provider", "github"
			property "sonar.coverage.exclusions", "**/src-jfx/**/*"
			property "sonar.coverage.jacoco.xmlReportPaths", "${rootDir}/JRomManager/build/reports/jacoco/codeCoverageReport/codeCoverageReport.xml"
		}
	}
/*	eclipse {
		classpath {
			file {
				whenMerged {
					//Define a module as being either a library or a project dependency.
					//Test sources are excluded because eclipse wants them on the classpath for some reason (1)
					entries.findAll {  (it instanceof org.gradle.plugins.ide.eclipse.model.Library || it instanceof org.gradle.plugins.ide.eclipse.model.ProjectDependency) && !it.entryAttributes.get('gradle_used_by_scope').equals('test') }.each {
						it.entryAttributes['module'] = 'true'
					}
				
					//Test-scoped stuff should set the appropriate flag
					entries.findAll {
							(it.properties.kind.equals('src') || it.properties.kind.equals('lib')) && it.entryAttributes.get('gradle_used_by_scope').equals('test')
					}.each {
						it.entryAttributes['test'] = 'true'
					}
					
					entries.findAll { isConGradle(it) }.each {
					  it.entryAttributes['module'] = 'true'
					}
				}
			}
		}
	}*/
/*
	java {
		modularity.inferModulePath = true
	}
	*/
	jar {
		manifest {
			attributes(
				"Manifest-Version"     : "1.0",
				"Specification-Title"  : "JRomManager",
				"Specification-Version": props.getProperty("Specification-Version"),
				"Implementation-Title" : "jrm",
				"Implementation-Version" : props.getProperty("Implementation-Version")
			)
		}
		archiveFileName = 'jrm-' + project.archivesBaseName + '-' + project.version + '.jar'
	}
	
	
	
	dependencies {
		constraints {
			implementation('commons-codec:commons-codec') {
				version {
					prefer '1.+'
				}
			}
			implementation('commons-io:commons-io') {
				version {
					prefer '2.+'
				}
			}
			implementation('com.beust:jcommander') {
				version {
					prefer '1.+'
				}
			}
			implementation('org.apache.commons:commons-text') {
				version {
					prefer '1.+'
				}
			}
			implementation('org.apache.commons:commons-compress') {
				version {
					prefer '1.+'
				}
			}
			implementation('org.apache.commons:commons-lang3') {
				version {
					prefer '3.+'
				}
			}
			implementation('one.util:streamex') {
				version {
					prefer '0.7.+'
				}
			}
			implementation('com.sun.activation:javax.activation') {
				version {
					prefer '[1.2.0,)'
				}
			}
			implementation('com.eclipsesource.minimal-json:minimal-json') {
				version {
					prefer '0.9.5'
				}
			}
			compileOnly('com.github.spotbugs:spotbugs-annotations') {
				version {
					prefer '3.1.+'
				}
			}
			implementation('com.atlassian.commonmark:commonmark') {
				version {
					prefer 'latest.release'
				}
			}
			implementation('org.eclipse.jetty:jetty-server') {
				version {
					prefer '9.+'
				}
			}
			implementation('org.eclipse.jetty:jetty-client') {
				version {
					prefer '9.+'
				}
			}
			implementation('org.eclipse.jetty:jetty-http') {
				version {
					prefer '9.+'
				}
			}
			implementation('org.eclipse.jetty:jetty-alpn-server') {
				version {
					prefer '9.+'
				}
			}
			implementation('org.eclipse.jetty:jetty-alpn-conscrypt-server') {
				version {
					prefer '9.+'
				}
			}
			implementation('org.eclipse.jetty:jetty-servlet') {
				version {
					prefer '9.+'
				}
			}
			implementation('org.eclipse.jetty.http2:http2-server') {
				version {
					prefer '9.+'
				}
			}
			implementation(group: 'com.google.code.gson', name: 'gson') {
				version {
					prefer 'latest.release'
				}
			}
			implementation('commons-dbutils:commons-dbutils') {
				version {
					prefer 'latest.release'
				}
			}
			implementation('com.h2database:h2') {
				version {
					prefer 'latest.release'
				}
			}
			implementation('de.mkammerer:argon2-jvm') { 
				version { 
					prefer 'latest.release' 
				}
			}
			implementation('org.mindrot:jbcrypt') { 
				version { 
					prefer '0.4' 
				}
			}
			implementation('org.awaitility:awaitility') {
				version {
					prefer '4.+'
				}
			}
			implementation('commons-io:commons-io') {
				version {
					prefer 'latest.release'
				}
			}
			implementation('commons-daemon:commons-daemon') {
				version {
					prefer 'latest.release'
				}
			}
			implementation('org.junit.jupiter:junit-jupiter-api') {
				version {
					prefer 'latest.release'
				}
			}
			implementation('org.junit.jupiter:junit-jupiter-engine') {
				version {
					prefer 'latest.release'
				}
			}
			implementation('net.java.dev.jna:jna') {
				version {
					prefer 'latest.release'
				}
			}
			implementation('net.lingala.zip4j:zip4j') {
				version {
					prefer 'latest.release'
				}
			}
		}
	}
}
/*
project(':JRomManager:trrntzip') {
	sourceSets {
		main {
			java {
				srcDirs = ["../../Jtrrntzip/src"]
			}
			resources {
				srcDirs = ["../../Jtrrntzip/src"]
			}
		}
	}
	dependencies {
		implementation group: 'commons-codec', name:'commons-codec'
		implementation group: 'commons-io', name: 'commons-io'
	}
}
*/

project(':WebClient') {
	sonarqube {
		skipProject = true
	}
}

project(':Jtrrntzip') {
	sonarqube {
		skipProject = true
	}
}

project(':JRomManager:jrmcore') {
	apply plugin: "io.freefair.lombok"
	
	apply plugin: 'org.javamodularity.moduleplugin'
	apply plugin: "eclipse"
	eclipse {
		classpath {
			file {
				whenMerged {
					//Define a module as being either a library or a project dependency.
					//Test sources are excluded because eclipse wants them on the classpath for some reason (1)
					entries.findAll {  (it instanceof org.gradle.plugins.ide.eclipse.model.Library || it instanceof org.gradle.plugins.ide.eclipse.model.ProjectDependency) && !it.entryAttributes.get('gradle_used_by_scope').equals('test') }.each {
						it.entryAttributes['module'] = 'true'
					}
				
					//Test-scoped stuff should set the appropriate flag
					entries.findAll {
							(it.properties.kind.equals('src') || it.properties.kind.equals('lib')) && it.entryAttributes.get('gradle_used_by_scope').equals('test')
					}.each {
						it.entryAttributes['test'] = 'true'
					}
					
					entries.findAll { isConGradle(it) }.each {
					  it.entryAttributes['module'] = 'true'
					}
				}
			}
		}
	}
	java {
		modularity.inferModulePath = true
	}
	
	sourceSets {
		main {
			java {
				srcDirs = ["../src"]
			}
			resources {
				srcDirs = ["../src"]
			}
		}
		test {
			java {
				srcDirs = ["../test"]
			}
		}
	}
	
	dependencies {
		implementation 'com.github.optyfr:SevenZipJBindingAllInOne:1.0'
		implementation project(':Jtrrntzip')
		implementation group: 'commons-codec', name:'commons-codec'
		implementation group: 'commons-io', name: 'commons-io'
		implementation group: 'org.apache.commons', name: 'commons-text'
		implementation group: 'org.apache.commons', name: 'commons-compress'
	//	implementation group: 'net.sf.sevenzipjbinding', name: 'sevenzipjbinding'
		implementation group: 'one.util', name: 'streamex'
		implementation group: 'com.sun.activation', name: 'javax.activation'
		implementation group: 'com.eclipsesource.minimal-json', name: 'minimal-json'
		implementation group: 'net.lingala.zip4j', name: 'zip4j'
	
		testImplementation group: 'org.junit.jupiter', name:'junit-jupiter-api'
		testRuntimeOnly group: 'org.junit.jupiter', name:'junit-jupiter-engine'
	}
	jar {
		manifest {
			attributes(
				"Specification-Title"  : "JRomManager Core",
				"Implementation-Title" : "jrmcore",
			)
		}
	}
	apply plugin:'jacoco'
}

project(':JRomManager:jrmcli') {
	apply plugin: "io.freefair.lombok"
	apply plugin: "org.beryx.jlink"
	
	apply plugin: 'org.javamodularity.moduleplugin'
	apply plugin: "eclipse"
	eclipse {
		classpath {
			file {
				whenMerged {
					//Define a module as being either a library or a project dependency.
					//Test sources are excluded because eclipse wants them on the classpath for some reason (1)
					entries.findAll {  (it instanceof org.gradle.plugins.ide.eclipse.model.Library || it instanceof org.gradle.plugins.ide.eclipse.model.ProjectDependency) && !it.entryAttributes.get('gradle_used_by_scope').equals('test') }.each {
						it.entryAttributes['module'] = 'true'
					}
				
					//Test-scoped stuff should set the appropriate flag
					entries.findAll {
							(it.properties.kind.equals('src') || it.properties.kind.equals('lib')) && it.entryAttributes.get('gradle_used_by_scope').equals('test')
					}.each {
						it.entryAttributes['test'] = 'true'
					}
					
					entries.findAll { isConGradle(it) }.each {
					  it.entryAttributes['module'] = 'true'
					}
				}
			}
		}
	}
	java {
		modularity.inferModulePath = true
	}
	
	sourceSets {
		main {
			java {
				srcDirs = ["../src-cli"]
			}
			resources {
				srcDirs = ["../src-cli"]
			}
		}
		test {
			java {
				srcDirs = ["../test-cli"]
			}
		}
	}
	dependencies {
		implementation project(':JRomManager:jrmcore')
		implementation group: 'com.beust', name: 'jcommander'
		implementation group: 'commons-io', name: 'commons-io'
		implementation group: 'org.apache.commons', name: 'commons-lang3'
		implementation group: 'com.eclipsesource.minimal-json', name: 'minimal-json'
	
		testImplementation group: 'org.junit.jupiter', name:'junit-jupiter-api'
		testRuntimeOnly group: 'org.junit.jupiter', name:'junit-jupiter-engine'
	}
	jar {
		manifest {
			attributes(
				"Specification-Title"  : "JRomManager CLI",
				"Implementation-Title" : "jrmcli",
			)
		}
	}
	apply plugin:'jacoco'
	
}

project(':JRomManager:res-icons') {
	sourceSets {
		main {
			java {
				srcDirs = ["../src-res-icons"]
			}
			resources {
				srcDirs = ["../src-res-icons"]
			}
		}
	}
	dependencies {
	}
	jar {
		manifest {
			attributes(
				"Specification-Title"  : "JRomManager Resources",
				"Implementation-Title" : "res-icons",
			)
		}
	}
}

project(':JRomManager:jrmstandalone') {
	apply plugin: "io.freefair.lombok"
	apply plugin: "org.beryx.jlink"

	apply plugin: 'org.javamodularity.moduleplugin'
	apply plugin: "eclipse"
	eclipse {
		classpath {
			file {
				whenMerged {
					//Define a module as being either a library or a project dependency.
					//Test sources are excluded because eclipse wants them on the classpath for some reason (1)
					entries.findAll {  (it instanceof org.gradle.plugins.ide.eclipse.model.Library || it instanceof org.gradle.plugins.ide.eclipse.model.ProjectDependency) && !it.entryAttributes.get('gradle_used_by_scope').equals('test') }.each {
						it.entryAttributes['module'] = 'true'
					}
				
					//Test-scoped stuff should set the appropriate flag
					entries.findAll {
							(it.properties.kind.equals('src') || it.properties.kind.equals('lib')) && it.entryAttributes.get('gradle_used_by_scope').equals('test')
					}.each {
						it.entryAttributes['test'] = 'true'
					}
					
					entries.findAll { isConGradle(it) }.each {
					  it.entryAttributes['module'] = 'true'
					}
				}
			}
		}
	}
	java {
		modularity.inferModulePath = true
	}
	
	sourceSets {
		main {
			java {
				srcDirs = ["../src-standalone"]
			}
		}
		test {
			java {
				srcDirs = ["../test-standalone"]
			}
		}
	}
	dependencies {
		implementation project(':JRomManager:jrmcore')
		implementation project(':JRomManager:res-icons')
		implementation group: 'commons-codec', name:'commons-codec'
		implementation group: 'com.beust', name: 'jcommander'
		implementation group: 'commons-io', name: 'commons-io'
		implementation group: 'org.apache.commons', name: 'commons-lang3'
		implementation group: 'one.util', name: 'streamex'
		implementation group: 'com.eclipsesource.minimal-json', name: 'minimal-json'
		implementation group: 'com.sun.activation', name: 'javax.activation'
	
		testImplementation group: 'org.junit.jupiter', name:'junit-jupiter-api'
		testRuntimeOnly group: 'org.junit.jupiter', name:'junit-jupiter-engine'
	}
	jar {
		manifest {
			attributes(
				"Manifest-Version"     : "1.0",
				"Specification-Title"  : "JRomManager Standalone",
			)
		}
	}
	apply plugin:'jacoco'
}

project(':JRomManager:jrmfx') {
	apply plugin: 'org.javamodularity.moduleplugin'
	apply plugin: "eclipse"
	apply plugin: "io.freefair.lombok"
	apply plugin: "org.beryx.jlink"
	apply plugin: "org.openjfx.javafxplugin"
	
	javafx {
		version = '17'
		modules = [ 'javafx.controls', 'javafx.fxml', 'javafx.web' ]
	}
	/*
	java {
		modularity.inferModulePath = false
	}
	*/
	eclipse {
		classpath {
			file {
				whenMerged {
					entries.findAll { it.properties.path.contains('jcommander') || it.properties.path.contains('minimal-json'); }.each {
						it.entryAttributes['module'] = 'true'
					}
				}
			}
			downloadSources = true
			downloadJavadoc = true
		}
	}
	
	sourceSets {
		main {
			java {
				srcDirs = ["../src-jfx"]
			}
			resources {
				srcDirs = ["../src-jfx"]
			}
		}
		test {
			java {
				srcDirs = ["../test-jfx"]
			}
		}
	}
	dependencies {
		implementation project(':JRomManager:jrmcore')
		implementation project(':JRomManager:res-icons')
		implementation group: 'com.beust', name: 'jcommander'
		implementation group: 'commons-io', name: 'commons-io'
		implementation group: 'org.apache.commons', name: 'commons-text'
		implementation group: 'org.apache.commons', name: 'commons-lang3'
		implementation group: 'com.google.code.gson', name: 'gson'
		implementation group: 'com.eclipsesource.minimal-json', name: 'minimal-json'
/*		implementation group: 'commons-codec', name:'commons-codec'
		implementation group: 'one.util', name: 'streamex'
		implementation group: 'com.sun.activation', name: 'javax.activation'
	
		testImplementation group: 'org.junit.jupiter', name:'junit-jupiter-api'
		testRuntimeOnly group: 'org.junit.jupiter', name:'junit-jupiter-engine'*/
	}
	jar {
		manifest {
			attributes(
				"Manifest-Version"     : "1.0",
				"Specification-Title"  : "JRomManager JFX",
				"Specification-Version": props.getProperty("Specification-Version"),
				"Implementation-Title"  : "jrm",
				"Implementation-Version" : props.getProperty("Implementation-Version"),
			)
		}
	}
}

project(':JRomManager:jrmserver') {
	apply plugin: "io.freefair.lombok"
	apply plugin: 'org.javamodularity.moduleplugin'
	apply plugin: "eclipse"
	eclipse {
		classpath {
			file {
				whenMerged {
					//Define a module as being either a library or a project dependency.
					//Test sources are excluded because eclipse wants them on the classpath for some reason (1)
					entries.findAll {  (it instanceof org.gradle.plugins.ide.eclipse.model.Library || it instanceof org.gradle.plugins.ide.eclipse.model.ProjectDependency) && !it.entryAttributes.get('gradle_used_by_scope').equals('test') }.each {
						it.entryAttributes['module'] = 'true'
					}
				
					//Test-scoped stuff should set the appropriate flag
					entries.findAll {
							(it.properties.kind.equals('src') || it.properties.kind.equals('lib')) && it.entryAttributes.get('gradle_used_by_scope').equals('test')
					}.each {
						it.entryAttributes['test'] = 'true'
					}
					
					entries.findAll { isConGradle(it) }.each {
					  it.entryAttributes['module'] = 'true'
					}
				}
			}
		}
	}
	sourceSets {
		main {
			java {
				srcDirs = ["../src-server"]
			}
		}
		test {
			java {
				srcDirs = ["../test-server"]
			}
		}
	}
	dependencies {
		implementation project(':JRomManager:jrmstandalone')
		implementation project(':JRomManager:jrmcore')
		implementation project(':JRomManager:res-icons')
		implementation group: 'com.beust', name: 'jcommander'
		implementation group: 'commons-io', name: 'commons-io'
		implementation group: 'org.apache.commons', name: 'commons-lang3'
		implementation group: 'org.eclipse.jetty', name:'jetty-server'
		implementation group: 'org.eclipse.jetty', name:'jetty-servlet'
		implementation group: 'org.eclipse.jetty', name:'jetty-security'
		implementation group: 'org.eclipse.jetty', name:'jetty-alpn-server'
		implementation group: 'org.eclipse.jetty', name:'jetty-alpn-conscrypt-server'
		implementation group: 'org.eclipse.jetty.http2', name:'http2-server'
		implementation group: 'com.eclipsesource.minimal-json', name: 'minimal-json'
		implementation group: 'com.google.code.gson', name: 'gson'
		implementation group: 'one.util', name: 'streamex'
		implementation group: 'commons-dbutils', name:'commons-dbutils'
		implementation group: 'com.h2database', name:'h2'
		implementation group: 'org.mindrot', name:'jbcrypt'
		implementation group: 'net.java.dev.jna', name:'jna'
		implementation group: 'de.mkammerer', name:'argon2-jvm'
		implementation files(WebClientJar)

		testImplementation group: 'org.eclipse.jetty', name: 'jetty-client'
		testImplementation group: 'org.eclipse.jetty', name: 'jetty-http'
		testImplementation group: 'org.awaitility', name: 'awaitility'
		testImplementation group: 'commons-io', name: 'commons-io'
		testImplementation group: 'commons-daemon', name:'commons-daemon'
		testImplementation group: 'org.junit.jupiter', name:'junit-jupiter-api'
		testRuntimeOnly group: 'org.junit.jupiter', name:'junit-jupiter-engine'
	}
	
	apply plugin: 'jacoco'
	test {
		useJUnitPlatform {
			includeEngines 'junit-jupiter'
		}
		jacocoTestReport {
			reports {
				xml.enabled true
			}
		}
		finalizedBy jacocoTestReport
	    testLogging {
	        // set options for log level LIFECYCLE
	        events TestLogEvent.FAILED,
	               TestLogEvent.PASSED,
	               TestLogEvent.SKIPPED,
	               TestLogEvent.STANDARD_OUT
	        exceptionFormat TestExceptionFormat.FULL
	        showExceptions true
	        showCauses true
	        showStackTraces true
	
	        // set options for log level DEBUG and INFO
	        debug {
	            events TestLogEvent.STARTED,
	                   TestLogEvent.FAILED,
	                   TestLogEvent.PASSED,
	                   TestLogEvent.SKIPPED,
	                   TestLogEvent.STANDARD_ERROR,
	                   TestLogEvent.STANDARD_OUT
	            exceptionFormat TestExceptionFormat.FULL
	        }
	        info.events = debug.events
	        info.exceptionFormat = debug.exceptionFormat
	
	        afterSuite { desc, result ->
	            if (!desc.parent) { // will match the outermost suite
	                def output = "Results: ${result.resultType} (${result.testCount} tests, ${result.successfulTestCount} successes, ${result.failedTestCount} failures, ${result.skippedTestCount} skipped)"
	                def startItem = '|  ', endItem = '  |'
	                def repeatLength = startItem.length() + output.length() + endItem.length()
	                println('\n' + ('-' * repeatLength) + '\n' + startItem + output + endItem + '\n' + ('-' * repeatLength))
	            }
	        }
	    }
	    systemProperty "JRomManager.rootPath", "${rootDir}"
	    systemProperty "file.encoding", "utf-8"
	}

	
	jar {
		manifest {
			attributes(
				"Specification-Title"  : "JRomManager Server",
				"Implementation-Title" : "jrmserver",
			)
		}
	}
}

dependencies {
	implementation project(':JRomManager:jrmstandalone')
	implementation project(':JRomManager:jrmfx')
	implementation project(':JRomManager:jrmcli')
	implementation project(':JRomManager:jrmserver')
}


jar {
	def mainClassName="jrm.JRomManager"
	manifest {
		def path =configurations.runtimeClasspath.filter { it.name.endsWith('.jar') }.collect { 'lib/' + it.getName() }.join(' ')
		attributes(
			"Manifest-Version"     : "1.0",
			"Specification-Title"  : "JRomManager",
			"Specification-Version": props.getProperty("Specification-Version"),
			"Implementation-Title" : "jrm",
			"Implementation-Version" : props.getProperty("Implementation-Version"),
			"Main-Class"           : mainClassName,
			"Class-Path"           : path
		)
		archiveFileName = project.archivesBaseName + '.jar'
	}
}

task cliFatJar(type: Jar) {
	def mainClassName="jrm.JRomManagerCLI"
	manifest {
		attributes(
			"Manifest-Version"     : "1.0",
			"Specification-Title"  : "JRomManager",
			"Specification-Version": props.getProperty("Specification-Version"),
			"Implementation-Title" : "jrm",
			"Implementation-Version" : props.getProperty("Implementation-Version"),
			'Main-Class': mainClassName
		)
	}
	duplicatesStrategy = DuplicatesStrategy.INCLUDE
	archiveBaseName = 'JRomManagerCLI'
	from(project(':JRomManager:jrmcli').sourceSets.main.output.classesDirs)
	from(project(':JRomManager:jrmcli').sourceSets.main.resources)
	from { project(':JRomManager:jrmcli').configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) } }
}

build.dependsOn cliFatJar 

task docZip(type: Zip, dependsOn: javadoc) {
	destinationDirectory = buildDir
	classifier "javadocs"
	from javadoc.outputs.files
	into "docs"
	archiveFileName = project.archivesBaseName + '-' + project.version + '-apidocs' + '.zip'
	destinationDirectory = file("$buildDir/distributions/")
}

task downloadWrapper(type: Download) {
	src 'https://download.tanukisoftware.com/wrapper/3.5.45/wrapper-delta-pack-3.5.45.zip'
	dest file("$buildDir/wrapper.zip")
	onlyIfModified true
}

task distZip2(type: Zip, dependsOn: [jar, ':WebClient:build',downloadWrapper]) {
	from (configurations.runtimeClasspath) {
		into('lib')
		exclude '*.zip'
		include '*.jar'
	}
	from (jar)
//	from (project(':JUpdater').jar)
	from (new File(project(':WebClient').buildDir,"/gwt/out")) {
		into('webclient')
	}
	from (new File(project(':WebClient').projectDir,"/war/index.html")) {
		into('webclient')
	}
	from ('certs') {
		into('certs')
	}
	from (zipTree(file("$buildDir/wrapper.zip"))) {
		exclude '*/bin/*.bat'
		exclude '*/*/*test*'
		exclude '*/*/*demo*'
		exclude '*/src/**'
		exclude '*/conf/*'
		eachFile { fcp ->
			fcp.path = fcp.path.replaceFirst("^wrapper-delta-pack-[0-9a-z\\.]*", 'wrapper')
			if(fcp.path.endsWith(".sh") || fcp.name.startsWith("wrapper")) {
				fcp.mode = 0755
			}
		}
		includeEmptyDirs false
  	}
	from ('dist/wrapper') {
		include '*.bat'
		include '*.sh'
		include '*.shconf'
		into 'wrapper/bin'
		fileMode = 0755
	}
	from ('dist/wrapper') {
		include 'wrapper.conf'
		into 'wrapper/conf'
	}
/*	from ('dist/wrapper') {
		include 'wrapper.dll'
		into 'wrapper/lib'
	}*/
	from ('dist/logs') {
		include '.do_not_delete'
		into 'logs'
		dirMode = 0777
	}
	from ('dist') {
		include '*.bat'
		include '*.sh'
		fileMode = 0755
	}
	archiveFileName = project.archivesBaseName + '-' + project.version + '.zip'
	destinationDirectory = file("$buildDir/distributions/")
}

build.dependsOn distZip2
build.dependsOn docZip

apply plugin: 'nebula.ospackage'

ospackage {
	packageName 'jrommanager'
	packageDescription 'A Mame and Retrogaming Rom Manager, Java alternative to ClrMamePro'
	release '1'
	type= BINARY
	license 'GPL-2'
	vendor 'optyfr'
	packager 'optyfr'
	maintainer 'optyfr'
	user 'root'
	permissionGroup 'root'
	into '/opt/jrommanager'
	url 'https://github.com/optyfr/JRomManager'
	from (configurations.runtimeClasspath) {
		into('lib')
		exclude '*.zip'
		include '*.jar'
	}
	from (jar)
//	from (project(':JUpdater').jar)
	from (zipTree(distZip2.archivePath)) {
		include 'wrapper/**'
		include 'webclient/**'
		include 'certs/**'
  	}
	from ('dist') {
		include '*.bat'
		include '*.sh'
		include '*.shconf'
		fileMode = 0755
	}
	from ('dist') {
		include name+'.desktop'
		into '/usr/share/applications'
	}
	from ('dist') {
		include name+'.png'
		into '/usr/share/pixmaps'
	}
	link('/usr/bin/jrommanager', '/opt/jrommanager/JRomManager-multi.sh')
}

buildDeb {
	requires('java17-runtime').or('java18-runtime')
	arch = "all"
}

buildRpm {
	requires('java', '1:17', EQUAL).or('java', '1:18', EQUAL)
	arch = NOARCH
	os = LINUX
	addParentDirs = false
	createDirectoryEntry = false
}

buildRpm.dependsOn distZip
buildRpm.dependsOn distZip2
build.dependsOn buildRpm
buildDeb.dependsOn distZip
buildDeb.dependsOn distZip2
build.dependsOn buildDeb

jlink {
//	options = ['--strip-debug', '--compress', '2', '--no-header-files', '--no-man-pages']
	mergedModuleName = "jrm.merged.module"
	customImage {
		appModules = ['jrm.merged.module','jrmstandalone','jrmfx','jrmcli','jrmserver']
	}
	launcher {
		name = 'JRomManager'
		moduleName = 'jrmstandalone'
		mainClass = 'jrm.JRomManagerMulti'
		jvmArgs = ['-XX:MaxRAMPercentage=75']
	}
	secondaryLauncher {
		name = 'JRomManagerFX'
		moduleName = 'jrmfx'
		mainClass = 'jrm.fx.JRomManagerMulti'
		jvmArgs = ['-XX:MaxRAMPercentage=75']
	}
	secondaryLauncher {
		name = 'JRomManagerCLI'
		moduleName = 'jrmcli'
		mainClass = 'jrm.cli.JRomManagerCLI'
		winConsole = true
		jvmArgs = ['-XX:MaxRAMPercentage=75']
	}
	secondaryLauncher {
		name = 'JRomManagerServer'
		moduleName = 'jrmserver'
		mainClass = 'jrm.server.Server'
		winConsole = true
		jvmArgs = ['-XX:MaxRAMPercentage=75']
		args = ['--workpath','%HOMEPATH%/.jrommanager']
	}
	secondaryLauncher {
		name = 'JRomManagerFullServer'
		moduleName = 'jrmserver'
		mainClass = 'jrm.fullserver.FullServer'
		winConsole = true
		jvmArgs = ['-XX:MaxRAMPercentage=75']
		args = ['--workpath','%HOMEPATH%/.jrommanager']
	}
	targetPlatform("win") {
//		jdkHome = jdkDownload("https://github.com/AdoptOpenJDK/openjdk11-binaries/releases/download/jdk-11.0.10%2B9/OpenJDK11U-jdk_x64_windows_hotspot_11.0.10_9.zip")
		jdkHome = jdkDownload("https://github.com/adoptium/temurin17-binaries/releases/download/jdk-17.0.1%2B12/OpenJDK17U-jdk_x64_windows_hotspot_17.0.1_12.zip")
	}
	targetPlatform("linux-x64") {
//		jdkHome = jdkDownload("https://github.com/AdoptOpenJDK/openjdk11-binaries/releases/download/jdk-11.0.10%2B9/OpenJDK11U-jdk_x64_linux_hotspot_11.0.10_9.tar.gz")
		jdkHome = jdkDownload("https://github.com/adoptium/temurin17-binaries/releases/download/jdk-17.0.1%2B12/OpenJDK17U-jdk_x64_linux_hotspot_17.0.1_12.tar.gz")
	}
	targetPlatform("macos-x64") {
//		jdkHome = jdkDownload("https://github.com/AdoptOpenJDK/openjdk11-binaries/releases/download/jdk-11.0.10%2B9/OpenJDK11U-jdk_x64_mac_hotspot_11.0.10_9.tar.gz")
		jdkHome = jdkDownload("https://github.com/adoptium/temurin17-binaries/releases/download/jdk-17.0.1%2B12/OpenJDK17U-jdk_x64_mac_hotspot_17.0.1_12.tar.gz")
	}
	jpackage {
		installerType = project.findProperty('installerType') // we will pass this from the command line (example: -PinstallerType=msi)
		targetPlatformName = project.findProperty('targetPlatform') // we will pass this from the command line (example: -PtargetPlatform=win)
		installerOutputDir = file("$buildDir/installer")
		imageName = 'JRomManager'
		icon = 'dist/JRomManager.ico'
		if (installerType == 'msi') {
			imageOptions += ['--icon', 'dist/JRomManager.ico']
			installerOptions += [
				'--win-dir-chooser', '--win-menu', '--win-shortcut'
			]
		}
		if (installerType == 'deb' || installerType=='rpm') {
			imageOptions += ['--icon', 'dist/JRomManager.png']
			installerOptions += [
				'--linux-package-name', 'jrommanager',
				'--linux-app-category', 'utils',
				'--linux-app-release', 1,
				'--linux-rpm-license-type', 'GPL-2',
				'--linux-menu-group', 'Utility',
				'--linux-shortcut'
			]
		}
		if (installerType == 'dmg') {
/*			imageOptions += ['--icon', 'dist/JRomManager.png']
			installerOptions += [
			]*/
		}
	}	
}
jpackage {
	doFirst {
		project.getProperty('installerType') // throws exception if its missing
		project.getProperty('targetPlatform') // throws exception if its missing
	}
}
